<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: random number generators | The Code Dungeon]]></title>
  <link href="http://tschoonj.github.io/blog/categories/random-number-generators/atom.xml" rel="self"/>
  <link href="http://tschoonj.github.io/"/>
  <updated>2016-08-28T18:04:22+01:00</updated>
  <id>http://tschoonj.github.io/</id>
  <author>
    <name><![CDATA[Tom Schoonjans]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[easyRNG: random number generators and distributions for C and Fortran]]></title>
    <link href="http://tschoonj.github.io/blog/2016/08/28/easyrng-random-number-generators-and-distributions-for-c-and-fortran/"/>
    <updated>2016-08-28T16:14:02+01:00</updated>
    <id>http://tschoonj.github.io/blog/2016/08/28/easyrng-random-number-generators-and-distributions-for-c-and-fortran</id>
    <content type="html"><![CDATA[<p>The C++ 2011 standard introduced a collection of templates, grouped together in the <code>&lt;random&gt;</code> header of the C++ standard library, with the goal of providing a number of random number generators (RNGs) as well as several commonly used random number distributions (RNDs) to sample from. Though reception appears mixed, at least they provided a welcome alternative to the very unreliable <code>rand</code> that ships with the standard C library.</p>

<p>However, this does not mean anything to those who are writing code in C and Fortran, and have no plans to switch to C++ in order to obtain RNG and RND functionality. Personally, I have been using for many years the RNGs and RNDs offered by the <a href="https://www.gnu.org/software/gsl/manual/html_node/">GNU Scientific Library (GSL)</a> and its <a href="https://github.com/reinh-bader/fgsl">Fortran bindings FGSL</a> (of which I am a major contributor).
I have found GSL and FGSL to offer both an elegant interface as well as excellent performance on all major platforms and architectures. A potential drawback for their adoption however, are their license: the <a href="https://www.gnu.org/licenses/gpl.html">GNU General Public License</a>, which makes it impossible to include into proprietary, closed source software, though this is no concern for me personally as all my projects are open source.</p>

<p>This ended up giving me the idea for a new open source project <em>easyRNG</em>, a thin wrapper around C++11&rsquo;s <code>&lt;random&gt;</code> templates, with an API inspired by GSL and FGSL. The name for the project was obvious actually:</p>

<ul>
<li>Easy to implement and maintain: I didn&rsquo;t have to write the random number generations and distributions myself (which is really, really hard)</li>
<li>Easy to use: based on the established and popular APIs offered by GSL and FGSL, which should feel familiar to everybody (see <a href="#Examples">examples</a>)</li>
<li>Easy to build and install: no dependencies required apart from a C++11 compliant compiler, and the C++ standard library to link against. Those in need of the Fortran bindings will have to install a Fortran compiler with full 2003 and partial 2008 support. GNU autotools was used for the installation script so Windows users will have to install a suitable shell (e.g. <a href="http://msys2.github.io">msys2</a>) to build easyRNG. It shouldn&rsquo;t be hard to get it working in Visual Studio though.</li>
<li>Easy to redistribute: I picked the <a href="https://en.wikipedia.org/wiki/BSD_licenses#3-clause_license_.28.22Revised_BSD_License.22.2C_.22New_BSD_License.22.2C_or_.22Modified_BSD_License.22.29">3-clause BSD</a> license, which means it can be included (even with modifications) into proprietary software, provided the original copyright notices  and disclaimer</li>
</ul>


<p>After a couple of weeks of work I launched easyRNG on <a href="https://github.com/tschoonj/easyRNG">Github</a>, where one can download the code, browse the docs and of course fork the code!</p>

<!-- more -->


<h2>Examples</h2>

<p>How to use easyRNG in your C/C++/Objective-C and Fortran code (compilation instructions can be found in the <a href="https://tschoonj.github.io/easyRNG/usage.html">docs</a>):</p>

<pre><code class="c">
#include &lt;easy_rnh.h&gt;
#include &lt;easy_randist.h&gt;
#include &lt;time.h&gt;

int main(int argc, char *argv[]) {
    // create a Mersenne Twister RNG 
    easy_rng *rng = easy_rng_alloc(easy_rng_mt19937);

    // seed with the time to get a unique sequence every time this program is run
    easy_rng_set(rng, (long unsigned int) time(NULL));

    // get a double precision real number in [0, 1[
    double val = easy_rng_uniform(rng);

    // sample a double precision real number from a gaussian distribution with standard deviation 5.0
    val = easy_ran_gaussian(rng, 5.0);

    // free the RNG
    easy_rng_free(rng);

    return 0;
}
</code></pre>

<pre><code class="fortran">
PROGRAM test
  USE, INTRINSIC :: ISO_C_BINDING
  USE :: easyRNG
  IMPLICIT NONE

  TYPE (easy_rng) :: rng
  REAL (C_DOUBLE) :: val

  ! interface for libc's time function
  INTERFACE
    FUNCTION easy_time(timer) BIND(C, NAME='time') RESULT(rv)
      USE, INTRINSIC :: ISO_C_BINDING
      IMPLICIT NONE
      TYPE (C_PTR), INTENT(IN), VALUE :: timer
      INTEGER (C_LONG) :: rv
    END FUNCTION easy_time
  END INTERFACE

  ! create a Mersenne Twister RNG 
  rng = easy_rng_alloc(easy_rng_mt19937)

  ! seed with the time to get a unique sequence every time this program is run
  CALL easy_rng_set(rng, easy_time(C_NULL_PTR))

  ! get a double precision real number in [0, 1[
  val = easy_rng_uniform(rng)

  ! sample a double precision real number from a gaussian distribution with standard deviation 5.0
  val = easy_ran_gaussian(rng, 5.0)

  ! free the RNG
  CALL easy_rng_free(rng)
END PROGRAM
</code></pre>

<p>easyRNG is also thread-safe, provided each thread has its either its own unique <code>easy_rng</code> instance, or alternatively if locking is used to ensure only one thread can use the RNG at a time (not recommended).</p>

<h2>Checking the correctness of the results</h2>

<p>The correctness of the random number distributions was verified by sampling large numbers of random numbers while calculating the running average and standard deviation of the generated numbers, followed by comparing the average and standard deviation with the theoretically predicted values. These were obtained using equations from the descriptions of the distributions on Wikipedia. A notable exception here is the Cauchy (AKA Lorentz) distribution for which no average and standard deviation is defined.</p>

<p>I added support to the easyRNG repository for both <a href="https://travis-ci.org/tschoonj/easyRNG">Travis-CI</a> (Linux and Mac OS X) and <a href="https://ci.appveyor.com/project/tschoonj/easyrng">Appveyor</a> (Windows). For the former, I configured a genuine barrage of combinations of compiler versions on the two platforms to ensure I could test easyRNG with as many versions of GCC and clang as possible.</p>

<p>This resulted in the identification of a version of clang that consistently produced wrong results: version 6.0, which shipped with Xcode 6.1 and 6.2, Apple&rsquo;s SDK for its Mountain Lion release. I did not manage to identify for which random number distributions they failed though.</p>

<p>One observation I made while running the test is that the F-distribution&rsquo;s standard deviation is varying rather wildly around the theoretical value. Since this appears to be the case for all platforms and compilers, it looks to me like an inherent property of the distribution.</p>

<h2>Performance</h2>

<p>A very important characteristic of any library providing random number generators is its performance since in many applications such as Monte Carlo simulations, huge numbers of random numbers will have to be generated. Since easyRNG merely wraps the C++11 RNGs and RNDs, their implementation in the C++ standard library will be the key factor here. In order to establish performance, I produced 100000000 uniformly distributed random integers using both easyRNG (easy_rng_get) and GSL (gsl_rng_get), for the random number generator types that (I believe) are present in both libraries, on several platforms.</p>

<p>In all cases, GSL was used as installed with the default package manager, meaning that it was compiled at optimization level 2 (<code>CXXFLAGS="-O2"</code>) using the default system compiler.</p>

<p>These comparisons should not be taken too seriously as they were not obtained under &lsquo;lab conditions&rsquo;, but they do reveal that the selected compiler and optimization level do impact the result, sometimes even in surprising ways&hellip;</p>

<p>The code to run these tests can be found in <a href="https://github.com/tschoonj/easyRNG/blob/master/tests/test2.c">test2.c</a>.</p>

<h3>Mac OS X 10.11.6, Xcode 7.3.1, clang Apple LLVM version 7.3.0 (system default), CXXFLAGS=-O2</h3>

<pre><code>Comparing easyRNG's mt19937 with GSL's mt19937
easyRNG 0.610597 s
GSL 0.407344 s
Comparing easyRNG's ranlux24 with GSL's ranlux
easyRNG 6.87464 s
GSL 9.56388 s
Comparing easyRNG's ranlux48 with GSL's ranlux389
easyRNG 23.3074 s
GSL 16.3843 s
Comparing easyRNG's minstd_rand0 with GSL's minstd
easyRNG 0.631972 s
GSL 0.543443 s
Comparing easyRNG's minstd_rand with GSL's fishman20
easyRNG 0.524086 s
GSL 0.553649 s
</code></pre>

<h3>Mac OS X 10.11.6, Xcode 7.3.1, clang Apple LLVM version 7.3.0 (system default), CXXFLAGS=-O3</h3>

<pre><code>Comparing easyRNG's mt19937 with GSL's mt19937
easyRNG 0.601218 s
GSL 0.413567 s
Comparing easyRNG's ranlux24 with GSL's ranlux
easyRNG 6.76775 s
GSL 9.43511 s
Comparing easyRNG's ranlux48 with GSL's ranlux389
easyRNG 23.0925 s
GSL 16.104 s
Comparing easyRNG's minstd_rand0 with GSL's minstd
easyRNG 0.624519 s
GSL 0.545767 s
Comparing easyRNG's minstd_rand with GSL's fishman20
easyRNG 0.515577 s
GSL 0.548885 s
</code></pre>

<h3>Mac OS X 10.11.6, Xcode 7.3.1, gcc 6.1.0 (Homebrew), CXXFLAGS=-O2</h3>

<pre><code>Comparing easyRNG's mt19937 with GSL's mt19937
easyRNG 0.51174 s
GSL 0.420167 s
Comparing easyRNG's ranlux24 with GSL's ranlux
easyRNG 6.76126 s
GSL 9.55059 s
Comparing easyRNG's ranlux48 with GSL's ranlux389
easyRNG 20.765 s
GSL 16.3402 s
Comparing easyRNG's minstd_rand0 with GSL's minstd
easyRNG 0.656705 s
GSL 0.567046 s
Comparing easyRNG's minstd_rand with GSL's fishman20
easyRNG 0.575031 s
GSL 0.557471 s
</code></pre>

<h3>Mac OS X 10.11.6, Xcode 7.3.1, gcc 6.1.0 (Homebrew), CXXFLAGS=-O3</h3>

<pre><code>Comparing easyRNG's mt19937 with GSL's mt19937
easyRNG 0.458188 s
GSL 0.408222 s
Comparing easyRNG's ranlux24 with GSL's ranlux
easyRNG 4.99809 s
GSL 9.62012 s
Comparing easyRNG's ranlux48 with GSL's ranlux389
easyRNG 16.4211 s
GSL 16.3106 s
Comparing easyRNG's minstd_rand0 with GSL's minstd
easyRNG 0.659607 s
GSL 0.571513 s
Comparing easyRNG's minstd_rand with GSL's fishman20
easyRNG 0.575066 s
GSL 0.565953 s
</code></pre>

<h3>Linux Ubuntu 16.04 Xenial, gcc 5.4.0, CXXFLAGS=-O2</h3>

<pre><code>Comparing easyRNG's mt19937 with GSL's mt19937
easyRNG 0.487993
GSL 0.514865
Comparing easyRNG's ranlux24 with GSL's ranlux
easyRNG 7.00267
GSL 4.91427
Comparing easyRNG's ranlux48 with GSL's ranlux389
easyRNG 21.6973
GSL 8.139
Comparing easyRNG's minstd_rand0 with GSL's minstd
easyRNG 0.51359
GSL 0.488009
Comparing easyRNG's minstd_rand with GSL's fishman20
easyRNG 0.514706
GSL 0.515695
</code></pre>

<h3>Linux Ubuntu 16.04 Xenial, gcc 5.4.0, CXXFLAGS=-O3</h3>

<pre><code>Comparing easyRNG's mt19937 with GSL's mt19937
easyRNG 0.497586
GSL 0.50192
Comparing easyRNG's ranlux24 with GSL's ranlux
easyRNG 5.34764
GSL 4.81555
Comparing easyRNG's ranlux48 with GSL's ranlux389
easyRNG 17.0988
GSL 8.12849
Comparing easyRNG's minstd_rand0 with GSL's minstd
easyRNG 0.509686
GSL 0.492514
Comparing easyRNG's minstd_rand with GSL's fishman20
easyRNG 0.508777
GSL 0.505121
</code></pre>

<h3>Linux Ubuntu 16.04 Xenial, clang 3.8.0, CXXFLAGS=-O2</h3>

<pre><code>Comparing easyRNG's mt19937 with GSL's mt19937
easyRNG 0.417623
GSL 0.498354
Comparing easyRNG's ranlux24 with GSL's ranlux
easyRNG 3.2451
GSL 4.82584
Comparing easyRNG's ranlux48 with GSL's ranlux389
easyRNG 11.4369
GSL 8.14133
Comparing easyRNG's minstd_rand0 with GSL's minstd
easyRNG 0.514472
GSL 0.499584
Comparing easyRNG's minstd_rand with GSL's fishman20
easyRNG 0.517101
GSL 0.513164
</code></pre>

<h3>Linux Ubuntu 16.04 Xenial, clang 3.8.0, CXXFLAGS=-O3</h3>

<pre><code>Comparing easyRNG's mt19937 with GSL's mt19937
easyRNG 0.545296
GSL 0.500088
Comparing easyRNG's ranlux24 with GSL's ranlux
easyRNG 3.24089
GSL 4.8667
Comparing easyRNG's ranlux48 with GSL's ranlux389
easyRNG 11.1006
GSL 8.17594
Comparing easyRNG's minstd_rand0 with GSL's minstd
easyRNG 0.517966
GSL 0.49886
Comparing easyRNG's minstd_rand with GSL's fishman20
easyRNG 0.509863
GSL 0.517385
</code></pre>

<h2>Conclusion</h2>

<p><em>easyRNG</em> is a little library that wraps the C++11 <code>&lt;random&gt;</code> templates for a number of popular random number generators and distributions, using an API based on the GNU Scientific Library.
It is primarily intended for people developing in C and Fortran, but it can also be used to great effect in C++ and Objective-C. I will probably also add support for Python at some point, using SWIG.</p>

<p>The code is hosted on <a href="https://github.com/tschoonj/easyRNG">Github</a>, <a href="https://tschoonj.github.io/easyRNG/">documentation</a> was produced with Doxygen and the officially released tarballs can be found <a href="http://lvserver.ugent.be/easyRNG/">here</a>.</p>

<p>Feel free to comment, fork the code and open issues!</p>
]]></content>
  </entry>
  
</feed>
