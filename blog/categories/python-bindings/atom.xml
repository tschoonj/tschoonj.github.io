<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: python-bindings | The Code Dungeon]]></title>
  <link href="http://tschoonj.github.io/blog/categories/python-bindings/atom.xml" rel="self"/>
  <link href="http://tschoonj.github.io/"/>
  <updated>2013-09-05T13:34:45+02:00</updated>
  <id>http://tschoonj.github.io/</id>
  <author>
    <name><![CDATA[Tom Schoonjans]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Building libtool modules: Python bindings]]></title>
    <link href="http://tschoonj.github.io/blog/2013/09/04/building-libtool-modules-python-bindings/"/>
    <updated>2013-09-04T10:47:00+02:00</updated>
    <id>http://tschoonj.github.io/blog/2013/09/04/building-libtool-modules-python-bindings</id>
    <content type="html"><![CDATA[<p>One of the software packages (<a href="http://github.com/tschoonj/xraylib">xraylib</a>) I am working on, consists of a C-library with bindings to a number of other languages such as Python, Fortran 2003, IDL, Java, Ruby, Lua and Perl. Apart from IDL and Fortran 2003, the source code for these bindings is generated automatically using <a href="http://www.swig.org">swig</a>, although with considerable language-specific modifications to the swig interface file.</p>

<p>The bindings source code afterwards needs to be compiled into a dynamically loadable library, which will then be loaded at runtime by the program whenever the user needs to use a function or variable from the bindings (actually from the underlying C-library, but exposed through the swig generated bindings).
As a rule, each programming language that supports such dynamically loadable libraries comes with specific instructions on how to generate the libraries from the bindings source code, often using platform independent tools.</p>

<p>However, these tools never seem to integrate well with autoconf and automake and lead to quite complicated Makefile.am files. A considerable more easy approach would consist of relying on libtool&rsquo;s functionality of generating these dynamically loadable libraries (called modules in the libtool documentation).
In this series of posts I will share my experiences on generating bindings to the aforementioned languages using libtool in a relatively clear and easy way. All the code has been tested on Linux and Mac OS X. It may also work on Windows though, provided you install a bash shell with the required tools.</p>

<p>In this first post I will discuss Python extension modules.</p>

<!--more-->


<h2>Checking for python development tools</h2>

<p>If you want to create an autotools based project consisting of a C-library and python bindings, then one of the first things that configure will need to check for is the presence of the python interpreter and the development kit consisting of the python headers and some essential tools.
I accomplished this by adding the following lines into configure.ac</p>

<p>{% codeblock lang:bash %}</p>

<h1>configure.ac snippet</h1>

<h1>copy paste into your own configure.ac file</h1>

<h1>check for swig</h1>

<p>AC_CHECK_PROGS([SWIG],[swig],[&ldquo;noswig&rdquo;])</p>

<h1>present configure with a command-line option to disable the python bindings</h1>

<p>AC_ARG_ENABLE([python],[AS_HELP_STRING([&mdash;disable-python],[build without the python bindings])],[enable_python=$enableval],[enable_python=check])</p>

<h1>default behavior is to install the python bindings into subfolders of $prefix</h1>

<h1>however, this may require the user to set the PYTHONPATH environment variable</h1>

<h1>in order to avoid this, invoke configure with the &mdash;enable-python-integration option</h1>

<p>AC_ARG_ENABLE([python-integration],[AS_HELP_STRING([&mdash;enable-python-integration],[install the python bindings in the interpreters site-packages folder])],[enable_python_integration=$enableval],[enable_python_integration=check])</p>

<p>VALID_PYTHON=</p>

<p>if test &ldquo;x$SWIG&rdquo; = xnoswig &amp;&amp; test &ldquo;x$enable_python&rdquo; = xyes ; then</p>

<pre><code>    #don't even bother when swig is not found
    AC_MSG_ERROR([--enable-python was given as an option but swig was not found on the system])
</code></pre>

<p>elif test &ldquo;x$SWIG&rdquo; = xswig &amp;&amp; test &ldquo;x$enable_python&rdquo; != xno ; then</p>

<pre><code>    #verify the python installation
    AM_PATH_PYTHON(,[PYTHON_FOUND=true],[PYTHON_FOUND=false])
    if test "x$PYTHON_FOUND" = xtrue ; then
            PYTHON_CPPFLAGS=
            PYTHON_LDFLAGS=
            AX_PYTHON_DEVEL
            if test "x$PYTHON" = x ; then
                    if test "x$enable_python" = xyes ; then
                            AC_MSG_ERROR([Incomplete python development package])
                    else
                            AC_MSG_WARN([Incomplete python development package])
                    fi
                    VALID_PYTHON=no
            else
                    VALID_PYTHON=yes
            fi

    fi
</code></pre>

<p>fi</p>

<p>if test &ldquo;x$VALID_PYTHON&rdquo; = xyes ; then</p>

<pre><code>AC_MSG_NOTICE([Building with Python bindings])


if test "x$enable_python_integration" = xyes ; then
        pythondir=$PYTHON_SITE_PKG
        pyexecdir=$PYTHON_SITE_PKG_EXEC
fi


AC_SUBST(PYTHONDIR,$pythondir)
AC_SUBST(PKGPYTHONDIR,$pkgpythondir)
AC_SUBST(PYEXECDIR,$pyexecdir)
AC_SUBST(PKGPYEXECDIR,$pkgpyexecdir)
</code></pre>

<p>fi</p>

<p>AM_CONDITIONAL([ENABLE_PYTHON],[test x$VALID_PYTHON = xyes])
{% endcodeblock %}</p>

<p>As can be seen from this snippet, I depend on two m4 macros to obtain the required information: <a href="http://www.gnu.org/software/automake/manual/html_node/Python.html">AM_PATH_PYTHON</a>, which searches for Python interpreter and subsequently sets a number of variables that will be used at installation time, and AX_PYTHON_DEVEL (I am using a heavily modified version of the code found at <a href="http://www.gnu.org/software/autoconf-archive/ax_python_devel.html">autoconf archives</a>), which will check for the required headers and perform a test compilation to make sure everything works.</p>

<h2>Writing the Makefile.am</h2>

<p>The Python way of building and installing extensions relies on the <a href="http://docs.python.org/3.3/distutils/setupscript.html#describing-extension-modules">Distutils package</a>, and is guaranteed to work on all platforms but integrates with difficulty into autotools based installation scripts.
However, recent versions of <a href="http://www.gnu.org/software/automake/manual/html_node/Python.html">automake</a> come with built-in support for installing python source files (and even byte-compile them), and comes with some recommendations on how to build your Python extensions module (possibly linked to a C-library as in our case) using libtool. The following example code is based upon these recommendations but also contains additional Makefile targets that deal with generating the Python extension module source through swig. Let&rsquo;s assume our original C-library is called <code>mytest</code>, and is located in the <code>src</code> subfolder of the source tree. The Python bindings will be built in the <code>python</code> subfolder.</p>

<p>In this example, I followed the Python recommendations with regard to naming the extension module:
{% blockquote <a href="http://www.python.org/dev/peps/pep-0008/#package-and-module-names">http://www.python.org/dev/peps/pep-0008/#package-and-module-names</a> PEP 8 &mdash; Style Guide for Python Code %}
When an extension module written in C or C++ has an accompanying Python module that provides a higher level (e.g. more object oriented) interface, the C/C++ module has a leading underscore.
{% endblockquote %}</p>

<p>In this case, the accompanying Python module will be automatically generated by swig, and will be called <code>mytest.py</code>, while the extension module will receive the libtool name <code>_mytest.la</code>. The actual library extension will be platform dependent (.so on Linux/Mac OS X, .dll on Windows).</p>

<p>{% codeblock lang:makefile %}</p>

<h1>python bindings will only be built if all buildtools are available, hence the following automake conditional</h1>

<p>if ENABLE_PYTHON</p>

<h1>our python extension module</h1>

<p>pyexec_LTLIBRARIES = <em>mytest.la
</em>mytest_la_CFLAGS = $(PYTHON_CFLAGS) -I$(top_srcdir)/include $(PYTHON_CPPFLAGS)</p>

<h1>link to the C-library</h1>

<h1>probably on Windows one will need to link against the python dll as well</h1>

<p>_mytest_la_LIBADD = ../src/mytest.la</p>

<h1>the source code for our extensions module</h1>

<h1>nodist because this file will be generated by swig</h1>

<p>nodist__mytest_la_SOURCES = mytest_wrap.c</p>

<h1>-module forces libtool to generate a dynamically loadable module</h1>

<p>_mytest_la_LDFLAGS = -avoid-version -module -shared -export-dynamic</p>

<h1>nodist because this file will be generated by swig</h1>

<p>nodist_python_PYTHON = mytest.py</p>

<h1>this line assumes that the swig interface file mytest.i is located in the src subdirectory</h1>

<p>mytest_wrap.c: $(top_srcdir)/src/mytest.i</p>

<pre><code>$(SWIG) -I${top_srcdir}/include -includeall -o mytest_wrap.c -python ${top_srcdir}/src/mytest.i
</code></pre>

<p>mytest.py: mytest_wrap.c</p>

<p>clean-local:</p>

<pre><code>rm -rf mytest_wrap.c mytest.py mytest.pyc
</code></pre>

<p>endif</p>

<p>{% endcodeblock %}</p>

<p>When writing an autotools based project using these guidelines, you should have no problem compiling and installing your python bindings and the C-library it depends on, with the familiar commands:</p>

<p><code>
./configure
make
make install
</code></p>

<h2>The code</h2>

<p>The full code follows: as usual it&rsquo;s a github gist so feel free to clone it and hack away at it.</p>

<p>{% gist 6441999 %}</p>
]]></content>
  </entry>
  
</feed>
