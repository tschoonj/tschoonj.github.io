<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: curl | The Code Dungeon]]></title>
  <link href="http://tschoonj.github.io/blog/categories/curl/atom.xml" rel="self"/>
  <link href="http://tschoonj.github.io/"/>
  <updated>2013-09-05T13:34:45+02:00</updated>
  <id>http://tschoonj.github.io/</id>
  <author>
    <name><![CDATA[Tom Schoonjans]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Checking for updates using git tags]]></title>
    <link href="http://tschoonj.github.io/blog/2013/07/08/checking-for-updates-using-git-tags/"/>
    <updated>2013-07-08T19:39:00+02:00</updated>
    <id>http://tschoonj.github.io/blog/2013/07/08/checking-for-updates-using-git-tags</id>
    <content type="html"><![CDATA[<p>At some point during the development of version 2.0 of my software package <a href="http://github.com/tschoonj/xmimsim">XMI-MSIM</a>, I decided to implement a routine that would allow for the program to check if newer versions (updates) were available. This would be extremely useful for the users of the Windows and Mac OS X builds of my package, since these operating systems do not come with package-management tools as most Linux distributions do (I am staying far away from Mac App Store and Windows store as I am not willing to pay their developer fees).</p>

<p>Initially I was looking at <a href="http://sparkle.andymatuschak.org">Sparkle</a>, a fantastic tool for OS X apps.
However, this would mean a different solution for my Windows build&hellip;</p>

<p>Since my goal is to keep the platform specific code as low as possible (#ifdef&rsquo;s really are quite ugly things), obviously I had to come up with a different solution.</p>

<!--more-->


<h2>Getting the tags with curl</h2>

<p>In a rare moment of clarity, I came up with the idea of using git tags for this. Like most people, I am using the tags to indicate releases, and as a rule I include the version number in the tagname (e.g. XMI-MSIM-1.0). My method consists of having a routine called <code>check_for_updates</code> (what&rsquo;s in a name?), download the list of tags from github.com (using the <a href="http://developer.github.com/v3/git/tags/">github v3 API for tags</a>). As I was writing (this part of) my application XMI-MSIM in C, I was looking for a library that could easily accomplish this. The quest yielded <a href="http://curl.haxx.se">libcurl</a>, an extremely versatile tool for transferring data using many, many protocols. The code I used for this was something like (full code at the end of this post):</p>

<p>{% codeblock lang:c %}</p>

<pre><code>//this line is obviously specific to your github account name and project name.
//Change it accordingly
#define XMIMSIM_GITHUB_TAGS_LOCATION "https://api.github.com/repos/tschoonj/xmimsim/git/refs/tags"

    char curlerrors[CURL_ERROR_SIZE];


    CURL *curl;
    CURLcode res;
    struct MemoryStruct chunk;

    chunk.memory = malloc(1);
    chunk.size = 0;

    fprintf(stdout,"checking for updates...\n");

    //setup curl
    curl = curl_easy_init();
    if (!curl) {
            fprintf(stderr,"Could not initialize cURL\n");
            return XMIMSIM_UPDATES_ERROR;
    } 

    curl_easy_setopt(curl, CURLOPT_URL,XMIMSIM_GITHUB_TAGS_LOCATION);
    curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L);
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void *)&amp;chunk);
    curl_easy_setopt(curl, CURLOPT_USERAGENT, "libcurl-agent/1.0");
    curl_easy_setopt(curl, CURLOPT_ERRORBUFFER, curlerrors);
    curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, 4L);
    res = curl_easy_perform(curl);
    if (res != 0) {
            fprintf(stderr,"check_for_updates: %s\n",curlerrors);
            return XMIMSIM_UPDATES_ERROR;
    }
    curl_easy_cleanup(curl);
</code></pre>

<p>{% endcodeblock %}</p>

<h2>Parse the JSON code with Json-Glib and compare versions</h2>

<p>The buffer that is returned in <code>chunk</code>, contains JSON code. To parse this, I used the Json-Glib library, a logical choice since my project is written in Gtk+ anyway&hellip; Code extract:</p>

<p>{% codeblock lang:c %}</p>

<pre><code>parser = json_parser_new();
    if (json_parser_load_from_data(parser, chunk.memory, -1,&amp;error) ==  FALSE) {
            if (error) {
                    fprintf(stderr,"check_for_updates: %s\n",error-&gt;message);
                    return XMIMSIM_UPDATES_ERROR;
            }
    }
    JsonNode *rootNode = json_parser_get_root(parser);
    if(json_node_get_node_type(rootNode) != JSON_NODE_ARRAY) {
            fprintf(stderr,"check_for_updates: rootNode is not an Array\n");
            return XMIMSIM_UPDATES_ERROR;
    }
    JsonArray *rootArray = json_node_get_array(rootNode);
    char *max_version = g_strdup(PACKAGE_VERSION);
    char *current_version = g_strdup(max_version);
    json_array_foreach_element(rootArray, (JsonArrayForeach) check_version_of_tag, &amp;max_version);

    int rv;
    if (g_ascii_strtod(max_version, NULL) &gt; g_ascii_strtod(current_version, NULL))
            rv = XMIMSIM_UPDATES_AVAILABLE;
    else
            rv = XMIMSIM_UPDATES_NONE;

    *max_version_rv = strdup(g_strstrip(max_version));

    g_object_unref(parser);
    fprintf(stdout,"done checking for updates\n");
</code></pre>

<p>{% endcodeblock %}</p>

<p>Important here is the <code>json_array_foreach_element</code> function, which will call <code>check_version_of_tag</code> for each tag, and update the highest found tag version number with each iteration.</p>

<p>After this, all that needs to be done is to compare this highest tag version with the internal version number (<code>PACKAGE_VERSION</code>, typically provided by a configure script), and the result is returned.</p>

<p>Now the method that I just described assumes that the version numbering is done with one major number and one minor number, allowing me to easily convert into a float for version comparison. Although this is sufficient for my personal needs, others may have to come up with a slightly more complex algorithm allowing to compare version numbers consisting of a major, minor and macro version number.</p>

<h2>The code</h2>

<p>This is the full code: feel free to hack away at it.
It is taken from <a href="https://github.com/tschoonj/xmimsim/blob/master/bin/xmimsim-gui-updater.c">xmimsim-gui-updater.c</a>, which also contains code to download the new packages from a webserver (also using curl).</p>

<p>{% gist 5951294 %}</p>
]]></content>
  </entry>
  
</feed>
