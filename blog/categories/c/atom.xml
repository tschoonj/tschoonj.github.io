<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: c | The Code Dungeon]]></title>
  <link href="http://tschoonj.github.io/blog/categories/c/atom.xml" rel="self"/>
  <link href="http://tschoonj.github.io/"/>
  <updated>2016-08-25T09:40:42+01:00</updated>
  <id>http://tschoonj.github.io/</id>
  <author>
    <name><![CDATA[Tom Schoonjans]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[easyRNG: random number generators and distributions for C and Fortran]]></title>
    <link href="http://tschoonj.github.io/blog/2016/08/20/easyrng-random-number-generators-and-distributions-for-c-and-fortran/"/>
    <updated>2016-08-20T16:14:02+01:00</updated>
    <id>http://tschoonj.github.io/blog/2016/08/20/easyrng-random-number-generators-and-distributions-for-c-and-fortran</id>
    <content type="html"><![CDATA[<p>The C++ 2011 standard introduced a collection of templates, grouped together in the <code>&lt;random&gt;</code> header of the C++ standard library, with the goal of providing a number of random number generators (RNGs) as well as several commonly used random number distributions (RNDs) to sample from. Though reception appears mixed, at least they provided a welcome alternative to the very unreliable <code>rand</code> that ships with the standard C library.</p>

<p>However, this does not mean anything to those who are writing code in C and Fortran, and have no plans to switch to C++ in order to obtain RNG and RND functionality. Personally, I have been using for many years the RNGs and RNDs offered by the <a href="https://www.gnu.org/software/gsl/manual/html_node/">GNU Scientific Library (GSL)</a> and its <a href="https://github.com/reinh-bader/fgsl">Fortran bindings FGSL</a> (of which I am a major contributor).
I have found GSL and FGSL to offer both an elegant interface as well as excellent performance on all major platforms and architectures. A potential drawback for their adoption however, are their license: the <a href="https://www.gnu.org/licenses/gpl.html">GNU General Public License</a>, which makes it impossible to include into proprietary, closed source software, though this is no concern for me personally as all my projects are open source.</p>

<p>This ended up giving me the idea for a new open source project <em>easyRNG</em>, a thin wrapper around C++11&rsquo;s <code>&lt;random&gt;</code> templates, with an API inspired by GSL and FGSL. The name for the project was obvious actually:</p>

<ul>
<li>Easy to implement and maintain: I didn&rsquo;t have to write the random number generations and distributions myself (which is really, really hard)</li>
<li>Easy to use: based on the established and popular APIs offered by GSL and FGSL, which should feel familiar to everybody (see <a href="#Examples">examples</a>)</li>
<li>Easy to build and install: no dependencies required apart from a C++11 compliant compiler, and the C++ standard library to link against. Those in need of the Fortran bindings, will have to install a Fortran compiler with full 2003 and some 2008 support. GNU autotools was used for the installation script</li>
<li>Easy to redistribute: I picked the <a href="https://en.wikipedia.org/wiki/BSD_licenses#3-clause_license_.28.22Revised_BSD_License.22.2C_.22New_BSD_License.22.2C_or_.22Modified_BSD_License.22.29">3-clause BSD</a> license, which means it can be included (even with modifications) into proprietary software, provided the original copyright notices  and disclaimer</li>
</ul>


<p>After a couple of weeks of work I launched easyRNG on <a href="https://github.com/tschoonj/easyRNG">Github</a>, where one can download the code, browse the docs and of course fork the code!</p>

<p>In the rest of this post I will cover some examples, performance and correctness of the results.</p>

<!-- more -->


<h2>Examples</h2>

<p>How to use easyRNG in your C/C++/Objective-C and Fortran code (compilation instructions can be found in the <a href="https://tschoonj.github.io/easyRNG/usage.html">docs</a>):</p>

<pre><code class="c">
#include &lt;easy_rnh.h&gt;
#include &lt;easy_randist.h&gt;
#include &lt;time.h&gt;

int main(int argc, char *argv[]) {
    // create a Mersenne Twister RNG 
    easy_rng *rng = easy_rng_alloc(easy_rng_mt19937);

    // seed with the time to get a unique sequence every time this program is run
    easy_rng_set(rng, (long unsigned int) time(NULL));

    // get a double precision real number in [0, 1[
    double val = easy_rng_uniform(rng);

    // sample a double precision real number from a gaussian distribution with standard deviation 5.0
    val = easy_ran_gaussian(rng, 5.0);

    // free the RNG
    easy_rng_free(rng);

    return 0;
}
</code></pre>

<pre><code class="fortran">
PROGRAM test
  USE, INTRINSIC :: ISO_C_BINDING
  USE :: easyRNG
  IMPLICIT NONE

  TYPE (easy_rng) :: rng
  REAL (C_DOUBLE) :: val

  INTERFACE
    FUNCTION easy_time(timer) BIND(C, NAME='time') RESULT(rv)
      USE, INTRINSIC :: ISO_C_BINDING
      IMPLICIT NONE
      TYPE (C_PTR), INTENT(IN), VALUE :: timer
      INTEGER (C_LONG) :: rv
    ENDFUNCTION easy_time
  ENDINTERFACE

  ! create a Mersenne Twister RNG 
  rng = easy_rng_alloc(easy_rng_mt19937)

  ! seed with the time to get a unique sequence every time this program is run
  CALL easy_rng_set(rng, easy_time(C_NULL_PTR))

  ! get a double precision real number in [0, 1[
  val = easy_rng_uniform(rng)

  ! sample a double precision real number from a gaussian distribution with standard deviation 5.0
  val = easy_ran_gaussian(rng, 5.0)

  ! free the RNG
  CALL easy_rng_free(rng)
ENDPROGRAM
</code></pre>

<p>easyRNG is also thread-safe, provided each thread has its either its own unique <code>easy_rng</code> instance, or alternatively if locking is used to ensure only one thread can use the RNG at a time (not recommended).</p>

<h2>Checking the correctness of the results</h2>

<p>The correctness of the random number distributions was verified by sampling large numbers of random numbers while calculating the running average and standard deviation of the generated numbers, followed by comparing the average and standard deviation with the theoretically predicted values. These were obtained using equations from the descriptions of the distributions on Wikipedia. A notable exception here is the Cauchy (AKA Lorentz) distribution for which no average and standard deviation is defined.</p>

<p>I added support to the easyRNG repository for both <a href="https://travis-ci.org/tschoonj/easyRNG">Travis-CI</a> (Linux and Mac OS X) and <a href="https://ci.appveyor.com/project/tschoonj/easyrng">Appveyor</a> (Windows). For the former, I configured a genuine barrage of combinations of compiler versions on the two platforms to ensure I could test easyRNG with as many versions of GCC and clang as possible.</p>

<p>This resulted in the identification of a version of clang that consistently produced wrong results: version 6.0, which shipped with Xcode 6.1 and 6.2, Apple&rsquo;s SDK for its Mountain Lion release. I did not manage to identify for which random number distributions they failed though.</p>

<p>I did notice that the F-distribution</p>

<h2>Performance</h2>

<p>A very important characteristic of any library providing random number generators is its performance since in many applications such as Monte Carlo simulations, huge numbers of random numbers will have to be generated. Since easyRNG merely wraps the C++11 RNGs and RNDs, their implementation in the C++ standard library will be the key factor here. In order to establish performance, I produced 100000000 uniformly distributed random integers using both easyRNG (easy_rng_get) and GSL (gsl_rng_get), for the random number generator types that (I believe) are present in both libraries, on several platforms.</p>

<p>In all cases, GSL was used as installed with the default package manager, meaning that it was compiled at optimization level 2 (<code>CXXFLAGS="-O2"</code>) using the default system compiler.</p>

<h3>Mac OS X 10.11.6, Xcode 7.3.1, clang 7.3.0 (system default), CXXFLAGS=-O2</h3>

<pre><code>Comparing easyRNG's mt19937 with GSL's mt19937
easyRNG 0.610597 s
GSL 0.407344 s
Comparing easyRNG's ranlux24 with GSL's ranlux
easyRNG 6.87464 s
GSL 9.56388 s
Comparing easyRNG's ranlux48 with GSL's ranlux389
easyRNG 23.3074 s
GSL 16.3843 s
Comparing easyRNG's minstd_rand0 with GSL's minstd
easyRNG 0.631972 s
GSL 0.543443 s
Comparing easyRNG's minstd_rand with GSL's fishman20
easyRNG 0.524086 s
GSL 0.553649 s
</code></pre>

<h3>Mac OS X 10.11.6, Xcode 7.3.1, clang 7.3.0 (system default), CXXFLAGS=-O3</h3>

<pre><code>Comparing easyRNG's mt19937 with GSL's mt19937
easyRNG 0.601218 s
GSL 0.413567 s
Comparing easyRNG's ranlux24 with GSL's ranlux
easyRNG 6.76775 s
GSL 9.43511 s
Comparing easyRNG's ranlux48 with GSL's ranlux389
easyRNG 23.0925 s
GSL 16.104 s
Comparing easyRNG's minstd_rand0 with GSL's minstd
easyRNG 0.624519 s
GSL 0.545767 s
Comparing easyRNG's minstd_rand with GSL's fishman20
easyRNG 0.515577 s
GSL 0.548885 s
</code></pre>

<h3>Mac OS X 10.11.6, Xcode 7.3.1, gcc 6.1.0 (Homebrew), CXXFLAGS=-O2</h3>

<pre><code>Comparing easyRNG's mt19937 with GSL's mt19937
easyRNG 0.51174 s
GSL 0.420167 s
Comparing easyRNG's ranlux24 with GSL's ranlux
easyRNG 6.76126 s
GSL 9.55059 s
Comparing easyRNG's ranlux48 with GSL's ranlux389
easyRNG 20.765 s
GSL 16.3402 s
Comparing easyRNG's minstd_rand0 with GSL's minstd
easyRNG 0.656705 s
GSL 0.567046 s
Comparing easyRNG's minstd_rand with GSL's fishman20
easyRNG 0.575031 s
GSL 0.557471 s
</code></pre>

<h3>Mac OS X 10.11.6, Xcode 7.3.1, gcc 6.1.0 (Homebrew), CXXFLAGS=-O3</h3>

<pre><code>Comparing easyRNG's mt19937 with GSL's mt19937
easyRNG 0.458188 s
GSL 0.408222 s
Comparing easyRNG's ranlux24 with GSL's ranlux
easyRNG 4.99809 s
GSL 9.62012 s
Comparing easyRNG's ranlux48 with GSL's ranlux389
easyRNG 16.4211 s
GSL 16.3106 s
Comparing easyRNG's minstd_rand0 with GSL's minstd
easyRNG 0.659607 s
GSL 0.571513 s
Comparing easyRNG's minstd_rand with GSL's fishman20
easyRNG 0.575066 s
GSL 0.565953 s
</code></pre>
]]></content>
  </entry>
  
</feed>
